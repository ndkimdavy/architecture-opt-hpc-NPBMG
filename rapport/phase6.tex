\section{Conclusion}

Ce projet nous a permis d’identifier les principaux facteurs influençant la performance d’applications de simulation numérique sur les architectures AMD et Intel. À travers l’étude du benchmark Multi-Grid (MG), nous avons constaté que l’optimisation ne dépend pas uniquement de l’algorithme, mais également de la structure du code et de la capacité du compilateur à exploiter efficacement le matériel. L’utilisation de MAQAO nous a notamment aidés à localiser les sections dominantes et à caractériser des freins majeurs liés à la vectorisation, à l’aliasing et aux contraintes mémoire.

La comparaison entre les versions C++ et Fortran a constitué un point central de notre analyse. Dans le cadre de ce benchmark, la version Fortran s’est révélée plus favorable à l’optimisation automatique par le compilateur AOCC, atteignant un score de compilation de 100~\%. Cet avantage s’explique en partie par la sémantique du Fortran et sa gestion native des tableaux multidimensionnels, qui réduisent les ambiguïtés d’aliasing et facilitent l’analyse statique du compilateur.

À l’inverse, l’optimisation de la version C++ (NPB-CPP) s’est révélée plus délicate et plus exigeante. Basée sur des structures de pointeurs plus complexes, elle présentait un score de compilation limité à 16,7~\%. Nous avons ainsi constaté que pour surmonter ces limitations structurelles, un effort de programmation supplémentaire est nécessaire : l’utilisation explicite de \texttt{\_\_restrict} et de pragmas \texttt{SIMD} s’est avérée indispensable pour lever les incertitudes du compilateur et encourager l’exploitation des unités vectorielles.

L’étude de la scalabilité a également mis en évidence des limites matérielles intrinsèques. Les gains de performance sont significatifs jusqu’à quatre threads, puis un plateau apparaît à huit threads, marqué par un Scalability Gap de 4,92 sur l’architecture AMD. Ce comportement confirme une saturation de la bande passante mémoire (profil \textit{memory bound}), rendant l’ajout de cœurs supplémentaires peu efficace. Enfin, le contrôle de l’affinité OpenMP s’est révélé crucial : le passage d’une stabilité d’affinité de 23,4~\% à 77,9~\% a été déterminant pour garantir la cohérence et la reproductibilité des mesures.

En définitive, ce travail montre que l’optimisation en HPC repose sur un compromis constant entre l’algorithme, le choix du langage et l’architecture matérielle. Si le C++ offre une grande flexibilité de développement, nos résultats indiquent que, dans un contexte de calcul intensif basé sur des stencils 3D, le Fortran conserve un avantage structurel pour faciliter le travail du compilateur et extraire la performance maximale du matériel.