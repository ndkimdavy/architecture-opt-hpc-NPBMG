\section{Conclusion}

Ce projet nous a permis d’identifier les principaux facteurs qui influencent la performance d’applications de simulation numérique sur les architectures AMD et Intel. À travers l’étude du benchmark Multi-Grid (MG), nous avons constaté que l’optimisation ne dépend pas uniquement de l’algorithme, mais aussi de la structure du code et de la capacité du compilateur à exploiter le matériel. L’utilisation de MAQAO nous a notamment aidés à localiser les sections dominantes et à caractériser des freins majeurs liés à la vectorisation, à l’aliasing et aux contraintes mémoire.

La comparaison entre les versions C++ et Fortran a été un point central de notre analyse. Dans le cadre de ce benchmark, la version Fortran s’est révélée plus favorable à l’optimisation automatique par le compilateur AOCC, atteignant un score de compilation de \textbf{100~\%}. Cet avantage s’explique en partie par la sémantique du Fortran et sa gestion native des tableaux multidimensionnels, qui réduit les ambiguïtés d’aliasing et facilite grandement l’analyse statique du compilateur.

À l’inverse, l’optimisation de la version C++ (NPB-CPP) s’est révélée plus délicate et exigeante. Basée sur des structures de pointeurs plus complexes, elle présentait un score de compilation limité à \textbf{16,7~\%}. Nous avons appris que pour vaincre ces limitations structurelles, il est nécessaire de pousser l'effort de programmation beaucoup plus loin : nous avons dû intervenir manuellement via l’utilisation de \texttt{\_\_restrict} et de pragmas \texttt{SIMD} afin de lever les incertitudes du compilateur et d’encourager l’utilisation des unités vectorielles.

L’étude de la scalabilité a également mis en évidence des limites matérielles intrinsèques. Les gains de performance sont nets jusqu’à quatre threads, puis un plateau apparaît à huit threads, marqué par un \textbf{Scalability Gap de 4,92} sur l’architecture AMD. Ce comportement confirme une saturation de la bande passante mémoire (profil \textit{memory bound}), rendant l’ajout de cœurs supplémentaire inefficace. Enfin, le contrôle de l’affinité OpenMP s’est avéré crucial : le passage d’une stabilité d’affinité de \textbf{23,4~\%} à \textbf{77,9~\%} a été une étape indispensable pour garantir la cohérence et la reproductibilité de nos mesures.

En définitive, ce travail montre que l’optimisation en HPC repose sur un compromis constant entre l’algorithme, le choix du langage et l’architecture matérielle. Si le C++ offre une grande flexibilité de développement, nos résultats indiquent que, dans ce contexte de calcul intensif de type stencil 3D, le Fortran conserve un avantage structurel pour faciliter le travail du compilateur et extraire la performance maximale du matériel.